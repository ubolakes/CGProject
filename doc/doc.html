<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
    <head>
        <meta charset="utf-8" />
        <meta name="generator" content="pandoc" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
        <meta name="author" content="Umberto Laghi" />
        <title>Documentation</title>
        <style>
            html {
            line-height: 1.5;
            font-family: Georgia, serif;
            font-size: 20px;
            color: #1a1a1a;
            background-color: #fdfdfd;
            }
            body {
            margin: 0 auto;
            max-width: 36em;
            padding-left: 50px;
            padding-right: 50px;
            padding-top: 50px;
            padding-bottom: 50px;
            hyphens: auto;
            overflow-wrap: break-word;
            text-rendering: optimizeLegibility;
            font-kerning: normal;
            }
            @media (max-width: 600px) {
            body {
                font-size: 0.9em;
                padding: 1em;
            }
            h1 {
                font-size: 1.8em;
            }
            }
            @media print {
            body {
                background-color: transparent;
                color: black;
                font-size: 12pt;
            }
            p, h2, h3 {
                orphans: 3;
                widows: 3;
            }
            h2, h3, h4 {
                page-break-after: avoid;
            }
            }
            p {
            margin: 1em 0;
            }
            a {
            color: #1a1a1a;
            }
            a:visited {
            color: #1a1a1a;
            }
            img {
            max-width: 100%;
            }
            h1, h2, h3, h4, h5, h6 {
            margin-top: 1.4em;
            }
            h5, h6 {
            font-size: 1em;
            font-style: italic;
            }
            h6 {
            font-weight: normal;
            }
            ol, ul {
            padding-left: 1.7em;
            margin-top: 1em;
            }
            li > ol, li > ul {
            margin-top: 0;
            }
            blockquote {
            margin: 1em 0 1em 1.7em;
            padding-left: 1em;
            border-left: 2px solid #e6e6e6;
            color: #606060;
            }
            code {
            font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
            font-size: 85%;
            margin: 0;
            }
            pre {
            margin: 1em 0;
            overflow: auto;
            }
            pre code {
            padding: 0;
            overflow: visible;
            overflow-wrap: normal;
            }
            .sourceCode {
            background-color: transparent;
            overflow: visible;
            }
            hr {
            background-color: #1a1a1a;
            border: none;
            height: 1px;
            margin: 1em 0;
            }
            table {
            margin: 1em 0;
            border-collapse: collapse;
            width: 100%;
            overflow-x: auto;
            display: block;
            font-variant-numeric: lining-nums tabular-nums;
            }
            table caption {
            margin-bottom: 0.75em;
            }
            tbody {
            margin-top: 0.5em;
            border-top: 1px solid #1a1a1a;
            border-bottom: 1px solid #1a1a1a;
            }
            th {
            border-top: 1px solid #1a1a1a;
            padding: 0.25em 0.5em 0.25em 0.5em;
            }
            td {
            padding: 0.125em 0.5em 0.25em 0.5em;
            }
            header {
            margin-bottom: 4em;
            text-align: center;
            }
            #TOC li {
            list-style: none;
            }
            #TOC ul {
            padding-left: 1.3em;
            }
            #TOC > ul {
            padding-left: 0;
            }
            #TOC a:not(:hover) {
            text-decoration: none;
            }
            code{white-space: pre-wrap;}
            span.smallcaps{font-variant: small-caps;}
            span.underline{text-decoration: underline;}
            div.column{display: inline-block; vertical-align: top; width: 50%;}
            div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
            ul.task-list{list-style: none;}
            pre > code.sourceCode { white-space: pre; position: relative; }
            pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
            pre > code.sourceCode > span:empty { height: 1.2em; }
            .sourceCode { overflow: visible; }
            code.sourceCode > span { color: inherit; text-decoration: inherit; }
            div.sourceCode { margin: 1em 0; }
            pre.sourceCode { margin: 0; }
            @media screen {
            div.sourceCode { overflow: auto; }
            }
            @media print {
            pre > code.sourceCode { white-space: pre-wrap; }
            pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
            }
            pre.numberSource code
            { counter-reset: source-line 0; }
            pre.numberSource code > span
            { position: relative; left: -4em; counter-increment: source-line; }
            pre.numberSource code > span > a:first-child::before
            { content: counter(source-line);
                position: relative; left: -1em; text-align: right; vertical-align: baseline;
                border: none; display: inline-block;
                -webkit-touch-callout: none; -webkit-user-select: none;
                -khtml-user-select: none; -moz-user-select: none;
                -ms-user-select: none; user-select: none;
                padding: 0 4px; width: 4em;
                color: #aaaaaa;
            }
            pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
            @media screen {
            pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
            }
            code span.al { color: #ff0000; font-weight: bold; } /* Alert */
            code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
            code span.at { color: #7d9029; } /* Attribute */
            code span.bn { color: #40a070; } /* BaseN */
            code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
            code span.ch { color: #4070a0; } /* Char */
            code span.cn { color: #880000; } /* Constant */
            code span.co { color: #60a0b0; font-style: italic; } /* Comment */
            code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
            code span.do { color: #ba2121; font-style: italic; } /* Documentation */
            code span.dt { color: #902000; } /* DataType */
            code span.dv { color: #40a070; } /* DecVal */
            code span.er { color: #ff0000; font-weight: bold; } /* Error */
            code span.fl { color: #40a070; } /* Float */
            code span.fu { color: #06287e; } /* Function */
            code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
            code span.kw { color: #007020; font-weight: bold; } /* Keyword */
            code span.op { color: #666666; } /* Operator */
            code span.ot { color: #007020; } /* Other */
            code span.pp { color: #bc7a00; } /* Preprocessor */
            code span.sc { color: #4070a0; } /* SpecialChar */
            code span.ss { color: #bb6688; } /* SpecialString */
            code span.st { color: #4070a0; } /* String */
            code span.va { color: #19177c; } /* Variable */
            code span.vs { color: #4070a0; } /* VerbatimString */
            code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
            .display.math{display: block; text-align: center; margin: 0.5rem auto;}
        </style>
    </head>

    <body>
        <header id="title-block-header">
            <h1 class="title">Documentazione Progetto di CG</h1>
            <p class="author">Umberto Laghi</p>
            <p class="date">A.A. 2023-2024</p>
        </header>
        
        <h1 id="indice">Indice</h1>
        <ul>
            <li><a href="#introduzione">Introduzione</a></li>
            <li><a href="#scene.js">Scena</a></li>
            <li><a href="#camera.js">Camera</a></li>
            <li><a href="#mesh_obj.js">Mesh Obj</a></li>
            <li><a href="#riferimenti">Riferimenti utilizzati</a></li>
        </ul>
        <hr />
        
        <h1 id="Introduzione">Introduzione</h1>
        <p> 
            Il seguente progetto è stato realizzato come prova 
            finale per il corso di "Fondamenti di Computer 
            Graphics M" tenuto dal professor Casciola.<br>
            L'obiettivo è sviluppare un'applicazione web 
            interattiva utilizzando la libreria grafica WebGL, 
            JavaScript e il linguaggio di shading OpenGL ES SL.
        </p>
        <figure>
        <img src="scena1.png" alt="Rendering di una scena" />
        <figcaption aria-hidden="true">Rendering di una scena</figcaption>
        </figure>
        <p> L'applicazione risultante consiste di una scena 3D 
            interagibile contenente più mesh 3D texturate.<br> 
            L'architettura del progetto consiste di più classi:
            <ul>
                <li><strong>scene.js:</strong>
                    è la classe più in alto nella gerarchia, si occupa 
                    di gestire tutte le altre.
                </li>
                <li><strong>camera.js:</strong>
                    è la classe che descrive la camera e ne gestisce i 
                    movimenti nell'ambiente 3D.
                </li>
                <li><strong>mesh_obj:</strong>
                    è la classe che rappresenta una mesh da disegnare.
                </li>
                <li><strong>main.js:</strong>
                    entry point del programma.
                </li>
                <li><strong>utils.js:</strong>
                    file che raccoglie metodi di supporto usati dalle 
                    altri classi.
                </li>
            </ul>
        </p>

        <h2 id="interfaccia">Interfaccia</h2>
        <p><img src="interfaccia.png" title="Interfaccia dell&#39;applicazione"/>
            L'interfaccia dell'applicazione è molto semplice: 
            da una parte c'è il canvas per disegnare la scena 
            e dall'altra una colonna contenente i comandi per 
            l'interazione e un menù a tendina per l'interazione.
        </p>
        <p>
            Per gestire le diversi impostazioni è stata 
            utilizzata la libreria 
            <a href="https://github.com/dataarts/dat.gui">dat.GUI</a>.
        </p>
        <p>
            Il movimento all'interno dell'ambiente 3D può essere gestito in due modi:
            <ul>
                <li>tramite <strong>tastiera</strong>, i cui tasti sono indicati a destra</li>
                <li>tramite <strong>touch</strong>, che sfrutta le gesture a cui siamo abituati sugli smartphone</li>
            </ul>
        </p>
        <p><img src="controlli.png"  width=50% height=50% style="display: block; margin-left: auto; margin-right: auto;"></p>
        <p>
            I tasti per controllare il movimento la direzione di vista sono visibili 
            espandendo il menù laterale, mentre per il touch è stata utilizzata la 
            libreria <a href="https://github.com/hammerjs/hammer.js">hammer.js</a>, 
            che si occupa di interpretare le interazioni tramite dispositivo touch
        </p>
        <p><a href="#indice">Torna all’indice</a></p>
        <hr/>
        <h1 id="scene.js">scene.js</h1>
        <p>
            Rappresenta la scena 3D e si occupa di orchestrare 
            tutte le operazioni: dall'inizializzazione del canvas 
            al rendering della scena stessa.
        </p>
        <p>
            All'istanziazione di un nuovo oggetto Scene, il metodo constructor 
            esegue le seguenti operazioni:
            <ul>
                <li>estrazione il contesto WebGL dal canvas</li>
                <li>impostazione delle dimensioni della viewport</li>
                <li>compilazione degli shader program</li>
                <li>lettura del file <strong>json</strong> contenente le mesh da mostrare</li>
                <li>per ogni mesh indicata nel file json viene istanziato un 
                    <strong>mesh_obj</strong> che viene salvato in una lista interna
                    all'oggetto Scene</li>
                <li>inizializzazione della <strong>camera</strong>, <strong>keys</strong>
                (struttura per la gestione dei tasti della tastiera), <strong>hammer.js</strong> e
                <strong>light</strong> (oggetto luce di scena)</li>
            </ul>
        </p>
        <p>
            Le mesh che verranno caricate e visalizzate sono indicate nel file json.
            Questa metodologia rende possibile creare più scene diverse semplicemente 
            modificando i file json.
        </p>
        <p>
            Di seguito è riportata la struttura tipo di una entry nel file json:
        </p>
        <div class="sourceCode" id="cb1"><pre
        class="sourceCode json"><code class="sourceCode json"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>  <span class="er">&quot;meshes&quot;:</span><span class="ot">[</span></span>
        <span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">{</span></span>
        <span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;name&quot;</span><span class="fu">:</span><span class="st">&quot;mesh_1&quot;</span><span class="fu">,</span></span>
        <span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;obj_source&quot;</span><span class="fu">:</span><span class="st">&quot;./path/mesh.obj&quot;</span><span class="fu">,</span></span>
        <span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;mtl_source&quot;</span><span class="fu">:</span><span class="st">&quot;./path/mesh&quot;</span><span class="fu">,</span></span>
        <span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;position&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="dv">0</span><span class="ot">,</span> <span class="dv">0</span><span class="ot">,</span> <span class="dv">0</span><span class="ot">]</span></span>
        <span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">}</span></span>
        <span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="ot">]</span></span></code></pre></div>
        <p>
            Ogni entry ha le seguenti proprietà:
            <ul>
                <li><strong>name:</strong>
                    nome della mesh, usato per il debug
                </li>
                <li><strong>obj_source:</strong> 
                    percorso del file .obj</li>
                <li><strong>mtl_source:</strong> 
                    percorso del file .mtl</li>
                <li><strong>position:</strong> 
                    posizione iniziale della mesh.</li>
            </ul>
        </p>
        <p>
            Il valore dell'attributo <strong>position</strong> 
            viene sommato alle coordinate della geometria 
            della mesh, traslandolo nella posizione desiderata.
        </p>

        <h2 id="metodi">Metodi</h2>

        <h3 id="async-load_mesh_jsonjson_path">async load_mesh_json( json_path )</h3>
        <p>
            Si occupa di leggere il file json contenente le mesh da caricare e 
            per ciascuno istanzia un oggetto mesh_obj che viene salvato in 
            <code>scene.mesh_list</code>.
        </p>

        <h3 id="projectionmatrix">projectionMatrix()</h3>
        <p>
            Si occupa di calcolare la projection matrix utilizzando la funzione
            <code>perspective(...)</code> della libreria m4.js.
        </p>

        <h3 id="key_controller">key_controller()</h3>
        <p>
            Si occupa di intercettare gli input da tastiera e invoca le funzioni 
            che modificano la posizione e la direzione della camera. <br>
            Questo metodo è realizzato in modo da poter gestire più input 
            contemporanei e consentire, ad esempio, di muoversi e girare la 
            camera nello stesso istante. <br>
            Viene invocata ogni qualvolta viene disegnato un frame.
        </p>

        <h3 id="async-prepareskybox">async prepareSkybox()</h3>
        <p>
            Si occupa di caricare la cubemap texture utilizzata per lo skybox. <br>
            I dati vengono poi salvati in <code>scene.skybox</code>.
        </p>

        <h3 id="async-prepareshadow">async prepareShadow()</h3>
        <p>
            Si occupa di preparare i dati per la gestione delle ombre,
            ovvero:
            <ul>
                <li>compilazione degli shaders necessari</li>
                <li>creazione di una texture utilizzata come depth map</li>
                <li>impostazione dei valori utilizzati durante il rendering.</li>
            </ul>
        </p>

        <h3 id="toggle_shadows">toggle_shadows()</h3>
        <p>
            Si occupa gestire lo switch dallo shader program 
            con ombre a quello senza e viceversa.
        </p>

        <h3 id="draw">draw()</h3>
        <p>
            Per motivi di scope non è un metodo della classe 
            Scene, ma una funzione a sé.<br>
            Si occupa di eseguire le seguenti operazioni:
            <ul>
                <li>ridimensionare canvas e viewport in base alla grandezza della
                finestra</li>
                <li>chiamare il metodo <code>key_controller()</code> per la 
                    gestione degli input da tastiera</li>
                <li>calcolare la projection e la view matrix</li>
                <li>la matrice di vista viene ottenuta da 
                    <code>scene.camera</code> che è un oggetto 
                    <code>Camera</code></li>
                <li>in base al valore di <code>scene.shadow.enable</code>:
                    <ul>
                        <li>viene eseguito il rendering con ombre</li>
                        <li>viene eseguito il rendering senza ombre</li>
                    </ul>
                </li>
            </ul>
        </p>
        <p>
            Per il rendering è abilitato <code>gl.BLEND</code> quindi, 
            se il materiale di una mesh ha opacità minore di uno, 
            questo verrà disegnato con una trasparenza.
        </p>

        <figure>
            <img src="trasparenza.png" title="Oggetto con trasparenza" alt="Esempio di trasparenza"/>
            <figcaption aria-hidden="true">Esempio di trasparenza</figcaption>
        </figure>

        <h3 id="rendering-base">Rendering base</h3>
        <p>
            La scena disegnata con lo shader program di base ha 
            le seguenti caratteristiche:
            <ul>
                <li>supporto per texture e colori</li>
                <li>luce diffusa</li>
                <li>specular lightning</li>
            </ul>
        </p>

        <figure>
            <img src="base.png" title="Scena disegnata con rendering base" alt="Rendering base"/>
            <figcaption aria-hidden="true">Rendering base</figcaption>
        </figure>

        <h3 id="rendering-con-ombre">Rendering con ombre</h3>
        <p>
            La tecnica di rendering avanzata implementata nel progetto 
            è il calcolo delle ombre, realizzata grazie alla tecnica 
            dello shadow mapping.
        </p>
        <p>
            // riguardare bene
            Per disegnare le ombre si parte dal punto di vista della luce, che 
            applica l'algoritmo di Shadow Buffer, che funziona in maniera 
            analoga allo Z-Buffer, considerando la distanza delle mesh da dal 
            punto luce.<br>
            Il risultato di questa operazione è la Shadow Map, che viene 
            considerata insieme alla Depth Map ottenuta dal punto di vista 
            dell'osservatore per determinare se un punto è in ombra oppure no. 
        </p>
        <figure>
            <img src="ombre.png" title="Stessa scena disegnata con le ombre" alt="Rendering con ombre" />
            <figcaption aria-hidden="true">Rendering con ombre</figcaption>
        </figure>
        <p><a href="#indice">Torna all’indice</a></p>
        <hr />

        <h1 id="camera.js">camera.js</h1>
        <p>
            Rappresenta la camera da cui viene osservata la scena.<br>
            Il punto di vista può essere spostato all'interno 
            dell'ambiente 3D in maniera libera.<br>
            L'orientamento della camera viene definito (ma anche 
            modificato) dai seguenti tre assi ortogonali espressi 
            in coordinate globali:
            <ul>
                <li><strong>position:</strong> posizione nello spazio</li>
                <li><strong>forward:</strong> vettore che punta di fronte alla camera</li>
                <li><strong>right:</strong> vettore che punta alla destra della camera</li>
                <li><strong>up:</strong> View-up vector, punta verso l’alto</li>
            </ul>
        </p>

        <h2 id="metodi-1">Metodi</h2>
        <h3 id="tiltstep">tilt( step )</h3>
        <p>
            Ruota la visuale in alto o in basso, si ottiene ruotando 
            la camera rispetto al vettore right.
        </p>

        <h3 id="panstep">pan( step )</h3>
        <p>
            Ruota la visuale orizzontalmente, si ottiene ruotando 
            la camera rispetto al View-up vector.
        </p>

        <h3 id="truckdist">truck( dist )</h3>
        <p>
            Modifica la posizione della camera lateralmente, lasciando 
            invariata la direzione della visuale. Si ottiene 
            moltiplicando il vettore right per <code>dist</code> e 
            sommando il risultato alla posizione attuale della camera.
        </p>

        <h3 id="pedestaldist">pedestal( dist )</h3>
        <p>
            Alza o abbassa la posizione della camera, si ottiene sommando 
            il prodotto tra il View-up vector e <code>dist</code> alla 
            posizione attuale della camera.
        </p>

        <h3 id="dollystep">dolly( step )</h3>
        <p>
            Avvicina o allontana la camera al punto osservato, 
            si ottiene sommando alla posizione attuale il 
            prodotto tra <code>dist</code> e il vettore forward.
        </p>

        <h3 id="realign">realign()</h3>
        <p>
            Riallinea la vista della camera all'orizzonte.
        </p>

        <h3 id="getviewmatrix">getViewMatrix()</h3>
        <p>
            Calcola e restituisce la viewMatrix. Il calcolo 
            viene eseguito utilizzando i metodi della 
            libreria m4.js.
        </p>

        <h3 id="getposition">getPosition()</h3>
        <p>
            Restituisce la posizione della camera.
        </p>

        <p><a href="#indice">Torna all’indice</a></p>

        <h1 id="mesh_obj.js">mesh_obj.js</h1>
        <p>
            Questa classe si occupa di gestire le mesh visibili, dal 
            loro caricamento fino al rendering.<br>
            Il costruttore prende le informazioni relative a una 
            mesh contenute in una entry del file json, quali:
            <ul>
                <li>percorso del file .obj</li>
                <li>percorso del file .mtl</li>
                <li>posizione della mesh rispetto all’origine</li>
            </ul>
        </p>
        <p>
            Le mesh sono salvate nella cartella <code>project/data</code>,
            alcuni sono stati scaricati da internet, mentre altri sono 
            stati disegnati su Blender.<br>
            Il formato utilizzato per l'utilizzo con WebGL è Wavefront obj, 
            a cui è associato il file mtl che descrive le proprietà dei 
            materiali che compongono le mesh.
        </p>

        <h2 id="metodi-2">Metodi</h2>

        <h3 id="prepare_meshgl">prepare_mesh( gl )</h3>
        <p>
            Si occupa di creare i buffer per passare gli attribute al 
            vertex shader, per fare ciò sfrutta la funzione 
            <code>createBufferInfoFromArrays(gl, data)</code> della 
            libreria webglUtils.js.
        </p>

        <h3 id="rendergl-programinfo-uniforms">render( gl, programInfo,
        uniforms )</h3>
        <p>
            Si occupa di disegnare la mesh utilizzando lo shader 
            program e gli uniform specificati nei parametri.<br>
            Tramite le funzioni della libreria webglUtils.js 
            vengono passati attribute e uniform allo shader 
            program. Utilizzando la funzione 
            <code>webglUtils.drawBufferInfo(gl, bufferInfo)</code> 
            viene invocata la <code>gl.drawElements</code> o la 
            <code>gl.drawArrays</code> in base alla presenza degli 
            indici o meno.
        </p>

        <p><a href="#indice">Torna all’indice</a></p>

        <hr />

        <h1 id="riferimenti">Riferimenti</h1>
        <p>
            Per la realizzazione del progetto, oltre alle slide e al codice visto
            durante il corso, è stato fatto riferimento ai seguenti articoli:
            <ul>
                <li><a
                href="http://learnwebgl.brown37.net/07_cameras/camera_introduction.html">Learn
                WebGL: Introduction to camera</a></li>
                <li><a
                href="https://webglfundamentals.org/webgl/lessons/webgl-3d-camera.html">WebGl
                Fundamentals: 3D Camera</a></li>
                <li><a
                href="https://webglfundamentals.org/webgl/lessons/webgl-load-obj-w-mtl.html">WebGL
                Fundamentals: Loading .obj with Mtl</a></li>
                <li><a
                href="https://webglfundamentals.org/webgl/lessons/webgl-shadows.html">WebGL
                Fundamentals: Shadows</a></li>
            </ul>
        </p>

        <p><a href="#indice">Torna all’indice</a></p>
        <hr />

    </body>
</html>
